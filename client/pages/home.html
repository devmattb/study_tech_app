<!--

***/
*
*   Created: 03 December 2017
*   @author Matt Bergstrom, A.K.A devmattb or Mattias Bergström.
*   Copyright 2017 Matt Bergstrom
*   Statement:
*   None of this code is to be copied or used without my (Matt Bergstroms') permission.
*
***/

-->
<template name="home">

  {{>header}}
  {{>preloader}}
  {{>navbar}}

  <div id="" class="row">
      <div class="col s12">
        <br><br>
        <h4 style="font-size: 26px; position: relative; bottom: -10px;" class="center grey-text text-darken-4">DAGENS SCHEMA</h4>
      </div>
      <div class="col s12">
        <div class="schedule"></div>
      </div>
      <div class="col s12">
        <button onclick="findSmth()" style="position: absolute; bottom 1000px!important; right: 100px;" class="red btn waves-effect waves-light"> TEST-BTN </button>
      </div>
  </div>

  <script>

/**
*
*     THE FOLLOWING IS ONLY TEST-CODE. USED FOR DEVELOPERS.
*     TODO: REMOVE.
*
**/

function formatDayOrMonth(dateNum){
  if (parseInt(dateNum) < 10 && dateNum.toString().substring(0,1) != "0") {
    dateNum = "0"+dateNum; // Make sure we have a zero before the numbers.
  }
  return dateNum;
}
Date.prototype.addHours = function(h) {
this.setTime(this.getTime() + (h*60*60*1000));
return this;
}



function returnExTypeResult (exType, mun, skr, lit, glo, upp) {

  if ( exType === "Muntlig Redovisning" ) {
    return mun;
  } else if ( exType === "Skriftligt Prov" ) {
    return skr;
  } else if ( exType === "Litteraturanalys" ) {
    return lit;
  } else if ( exType === "Glosor" ) {
    return glo;
  } else if ( exType === "Uppsats" ) {
    return upp;
  }

}

/**
*
*   getMinimumNumSesh():
*   Gets the minumum amount of sessions for a specific
*   course+examination-type combination
*   @param cType is the Course Type.
*   @param exType is the Examination Type.
*
**/
function getMinimumNumSesh(cType, exType) {

  var minSessions;
  if ( cType === "Språk" ) {
    minSessions = returnExTypeResult(exType, 4,3,3,1,4);
  } else if ( cType === "Samhällskunskap" ) {
    minSessions = returnExTypeResult(exType, 4,3,null,null,4);
  } else if ( cType === "Kvantitativ" ) {
    minSessions = returnExTypeResult(exType, null,3,null,null,null);
  }
  return minSessions;

}

  function findSmth() {

      // NOTE: Test activity Sorting
      var exType = "Skriftligt Prov";
      var cType = "Samhällskunskap";
      numStudySessions = 14;
      var minNumSesh = getMinimumNumSesh(cType, exType);
      // Calculate number of cycles:
      var cycles = Math.floor(numStudySessions/minNumSesh);
      // Get the number of optional activities we have time for:
      var numOptional = numStudySessions - cycles*minNumSesh;

      var allActivityObj = Activities.find();
      var activityArray = new Array();
      var listActivityDesc = new Array();

      // Get the entire description sequence, for all cycles:
      for (var k = 0; k < cycles; k++) {

          /**
          *   Get all activities that match our course-and-examination type from
          *   our DB in to an Array, called activityArray.
          **/
          allActivityObj.forEach(function(data){

            // Loop: Go through the coursetypes of each activity object.
            for (var i = 0; i < data.courseType.length; i++) {

              if (data.courseType[i] === cType && data.examinationType[i] === exType)  {
                // Add this particular index to our JSON object,
                // So we know exaclty what spot to look in the
                // phase, phaseOrder and examinationType array.
                if (data.optional[i] === true && numOptional > 0) {
                  // This is an optional Activity. But we still have room for some.
                  data.relevantIndex = i;
                  activityArray.push(data); // Add to our forbiddenTimesArr.
                  numOptional--; // Decrement the number of optionals we have space for.
                  break; // Break out of loop. Go to next activity.
                } else if (data.optional[i] === false) {
                  // This is a mandatory activity. Add it.
                  data.relevantIndex = i;
                  activityArray.push(data); // Add to our forbiddenTimesArr.
                  break; // Break out of loop. Go to next activity.
                }
              }

            }

          });
        } // Now we have the entire activity sequence, for all cycles, ready for sorting!


      // Sorts all activities in Ascending order, in this array,
      // according to their phase and phaseOrder. Chronological phases...
      activityArray.sort(function(dataA, dataB){

        if ( dataA.phase[dataA.relevantIndex] == dataB.phase[dataB.relevantIndex] ) { // Same phase.
          return dataA.phaseOrder[dataA.relevantIndex]-dataB.phaseOrder[dataB.relevantIndex]; // Sort by internal phaseOrder instead...
        } else { // Not same phase
          return dataA.phase[dataA.relevantIndex]-dataB.phase[dataB.relevantIndex]; // Sort by phase.
        }

      });

      // Put only the description strings of these activities in a list.
      // Note that this list is still sorted.
      activityArray.forEach(function(data){
          listActivityDesc.push(data.desc); // Add to our forbiddenTimesArr.
      });

      console.log(listActivityDesc.length);


      // NOTE: Test Date handling:
      // var startFromDay = new Date();
      // var tmp = new Date("2018-03-02 16:00:00");
      // var preliminaryDateObj = new Date(""+startFromDay.getFullYear()
      // +"-"+formatDayOrMonth(startFromDay.getMonth()+1)
      // +"-"+formatDayOrMonth(startFromDay.getDate())
      // + " 16:00:00");
      // console.log(preliminaryDateObj.addHours(2).getHours());
      // console.log(tmp-preliminaryDateObj);


  }

  </script>

  </template>
